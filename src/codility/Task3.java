package codility;

import java.util.Arrays;
import java.util.PriorityQueue;

/**
 * title: Task3
 * date: 2024.11.11
 * author: yun young
 * description
 * 하나의 도미노 알은 두 개의 정사각형부가 연이어 구성된 직사각형의 형태라고 합시다.
 * 또 정사각형 부에는 16개의 점이 찍혀있다고 합시다.
 *
 * 2*N 길이의 배열 A에서 N개의 도미노 알이 있다고 합시다. 이들 도미노 알은 직선으로 정렬되어 있으며
 * K번째로 배열된 도미노 알의 좌우 정사각형부에 찍힌 점의 수는 각각 A[2*K], A[2*K+1] 라고 합시다.
 *
 * 예를 들어, 배열 A가 [2,4,1,3,4,6,2,4,1,6] 라면 이는 각 정사각형부에 찍힌 점의 개수가 (2,4), (1,3), (4,6), (2,4), (1,6)인
 * 총 다섯알의 도미노로 구성된 배열을 표시하는 것 입니다.
 *
 * 앞선 도미노 알의 우측 정사각형부와 다음 도미노 알의 좌측 정사각형 부에 찍힌 점의 개수가 동일한 경우를
 * 올바른 도미노 배열이라고 표현한다고 합시다.
 * 가령 (2,4), (4,6)의 도미노 알 배열은 '올바른' 도미노 배열이며
 * (2,4), (1,3)의 도미노 배열은 '올바르지 않은' 도미노 배열 입니다.
 *
 * 그렇다면 주어진 도미노 배열이 올바르게 되기 위하여 삭제되어야할 도미노 알의 최소 개수를 산출하는 알고리즘을 짜봅시다.
 * 여기서, 주어진 도미노 알을 재배열하거나 뒤집을 수는 없다고 가정합시다.
 *
 * 도미노 알 N개로 구성된 배열 A이 올바른 도미노 배열이 되도록 하기 위하여 삭제되어야 할 도미노 알의 최소개수가 리턴되어야 합니다.
 *
 * Example
 * 1. A=[2,4,1,3,4,6,2,4,1,6]일 시 위 함수는 3을 리턴해야 합니다. 두번째 알과 마지막 두 알이 삭제되어 (2,4), (4,6)만 남게 되면 ‘올바른’ 배열이 되기 때문입니다.
 * 2. A =[5,1,2,6,6,1,3,1,4,3,4,3,4,6,1,2,4,1,6,2]일 시 위 함수는 7을 리턴하여야 합니다. 최종적으로 (2,6), (6,1), (1,2)만 남아야 올바른 배열이 되기 때문입니다.
 * 3. A=[1,5,3,3,1,3] 일 시 위 함수는 2를 리턴하여야 합니다. 주어진 도미노 알을 재배열하거나 뒤집지 않는 한 올바른 배열로 만들기가 불가능하기 때문입니다.
 * 4. A=[3,4]일 시 위 함수는 0을 리턴하여야 합니다.
 *
 * 문제 풀이
 * 도미노는 (A[2*k], A[2*K+1]) 형태로 구성된다.
 * (A[2*K+1] == A[2*(k+1)]가 성립하지 않는다면 해당 도미노 또는 다음 도미노를 삭제해야 한다.
 * 최적의 삭제 수를 계산하기 위해 동적계획법(DP) 또는 그리디 알고리즘을 사용할 수 있다.
 * 여기서는 최장 증가 부분 수열(Longest Increasing Subsequence, LIS) 접근법과 비슷한 DP 방법을 사용한다.
 */
public class Task3 {

    /**
     * TODO
     * 1. 초기화
     *   n은 도미노의 개수로 A.length / 2 로 계산
     *   dp 배열은 각 도미노가 포함될 때 형성될 수 있는 올바른 배열의 최대 길이를 저장. 기본값은 1로 초기화
     *
     * 2. DP 배열 갱신
     *   이중 for 루프를 사용해 각 도미노의 쌍을 비교
     *   j번째 도미노의 오른쪽 값이 i번째 도미노의 왼쪽 값과 같으면 dp[i]를 갱신
     *   dp[i] = Math.max(dp[i], dp[j]+1)로 현재까지의 최대 길이를 갱신
     * 3. 최대 길이 추적
     *   maxSequence는 가장 긴 올바른 배열의 길이를 추적
     *
     * 4. 최소 삭제 수 계산
     *   최소 삭제 개수는 전체 도미노 개수에서 가장 긴 올바른 배열의 길이를 뺀 값
     */
    public int solution(int[] A) {
        int n = A.length / 2; // 도미노 알의 개수
        if (n <= 1) return 0; // 도미노가 1개 이하라면 이미 올바른 배열이므로 삭제할 필요 없음


        // DP 배열 초기화
        int[] dp = new int[n];
        Arrays.fill(dp, 1);

        int maxSequence = 1;

        // 모든 도미노 쌍을 순차적으로 비교
        for (int i = 1; i < n; i++) {
            for (int j = 0; j < i; j++) {
                // j번째 도미노의 오른쪽 값이 i번째 도미노의 왼쪽 값과 같을 때
                if (A[2 * j + 1] == A[2 * i]) {
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            // 가장 긴 올바른 배열의 길이 갱신
            maxSequence = Math.max(maxSequence, dp[i]);
        }

        // 최소 삭제 개수 = 전체 도미노 개수 - 가장 긴 올바른 배열의 길이
        return n - maxSequence;
    }
}
